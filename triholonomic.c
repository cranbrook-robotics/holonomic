#pragma config(Sensor, port2,  pTouch,         sensorVexIQ_LED)
#pragma config(Sensor, port8,  pGyro,          sensorVexIQ_Gyro)
#pragma config(Motor,  motor3,          mpDriveA,      tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor4,          mpDriveC,      tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor10,         mpDriveB,      tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor9,         mpHeading,     tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include <CKGeneral.h>
#include <CKVex.h>


TVexJoysticks JoyChDriveX = JoyChLX;
TVexJoysticks JoyChDriveY = JoyChLY;
TVexJoysticks JoyChDriveR = JoyChRX;

#define getJoyDriveY()	( getJoystickValue(JoyChDriveY) / ControllerJoyMax )
#define getJoyDriveX()	( getJoystickValue(JoyChDriveX) / ControllerJoyMax )
#define getJoyDriveR()	( getJoystickValue(JoyChDriveR) / ControllerJoyMax )


const int MaxNWheels = 8;

int NWheels = 0;
float InitialWheelHeading = 0;
tMotor MotorPorts[MaxNWheels];
float WheelHeadings[MaxNWheels];


task main() {

	memset( MotorPorts, 0, sizeof(tMotor) * MaxNWheels );
	memset( WheelHeadings, 0, sizeof(float) * MaxNWheels );

	tMotor ports[] = { mpDriveA, mpDriveB, mpDriveC };
	NWheels = 3;
	InitialWheelHeading = degreesToRadians(60);

	// Compute the orientation of each wheel based on the assumption that
	// they are arranged in a regular polygonal form.
	float headingIncrement = 2*PI / NWheels;
	for( int i = 0; i < NWheels; ++i ){
		WheelHeadings[i] = i * headingIncrement + InitialWheelHeading;
	}

	float wheelPowers[MaxNWheels];

	setTouchLEDRGB(pTouch, 255, 0, 0);
	startGyroCalibration(pGyro, 2048);
	while( getGyroCalibrationFlag(pGyro) )
		sleep(50);
	resetGyro(pGyro);
	setTouchLEDRGB(pTouch, 0, 255, 0);

	while(true){
		float robotHeading = getGyroHeading(pGyro);

		setMotorTarget(mpHeading, (int)robotHeading, 100);
		displayTextLine(1, "%d", (int)robotHeading);

		robotHeading = degreesToRadians(robotHeading);

		// First obtain the joystick components: X, Y, and R
		float driveY = getJoyDriveY();
		float driveX = getJoyDriveX();
		float driveRotation = -getJoyDriveR();
		// Negative of the the rotational joystick because leftward rotation
		// is actually positive rotation about the vertical axis.

		// Transform the translational drive control vector from Cartesian
		// form into angle & magnitude form.
		float driveHeading = atan2(driveY, driveX) + robotHeading;
		float driveMagnitude = sqrt( driveX*driveX + driveY*driveY );

		float maxPower = 0; // Keep track of the max power magnitude for later

		for( int i = 0; i < NWheels; ++i ){
			// Angle of this particular wheel with the target drive heading.
			// For example, 0 or 180 would mean that this wheel is perfectly aligned with
			// the translational drive direction, and 90 or 270 would mean that it is
			// perfectly perpendicular.
			float angleWithTarget = ( driveHeading - WheelHeadings[i] );

			// Incorporate both the translational vector (relative to this wheel), as
			// well as the rotation.  This addition of the rotation is what causes
			// the motor powers to sometimes go over the full power amount.
			float thisPower = driveMagnitude * cos(angleWithTarget) + driveRotation;

			wheelPowers[i] = thisPower;

			// Check for a new maximum motor power magnitude.
			if( fabs(thisPower) > maxPower ){
				maxPower = fabs(thisPower);
			}
		}

		// If any of the calculated motor powers are greater than full power,
		// we need to reduce all motor powers by the same factor such that
		// the motor with the greatest power is given full power.
		float powerFactor = MotorPowerMax * (maxPower > 1.0 ? (1.0/maxPower) : 1.0);
		for( int i = 0; i < NWheels; ++i ){
			motor[ MotorPorts[i] ] = (int)round( powerFactor * wheelPowers[i] );
		}
	}
}
