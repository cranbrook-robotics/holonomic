#pragma config(Sensor, port2,  pTouch,         sensorVexIQ_LED)
#pragma config(Sensor, port8,  pGyro,          sensorVexIQ_Gyro)
#pragma config(Motor,  motor3,          mpDriveA,      tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor4,          mpDriveC,      tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor10,         mpDriveB,      tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor12,         mpHeading,     tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include <CKGeneral.h>
#include <CKVex.h>


#define JoyChDriveX		JoyChLX
#define JoyChDriveY		JoyChLY
#define JoyChDriveR		JoyChRX

//this line is only a comment.

#define getJoyDriveY()	getJoystickValue(JoyChDriveY)
#define getJoyDriveX()	getJoystickValue(JoyChDriveX)
#define getJoyDriveR()	getJoystickValue(JoyChDriveR)

const int NWheels = 3;
const float InitialWheelHeadingDeg = 60;
const int MotorPorts[NWheels] = { mpDriveA, mpDriveB, mpDriveC };


task main() {
	float headingIncrement = 360.0 / NWheels;
	float WheelHeadings[NWheels];
	for( int i = 0; i < NWheels; ++i ){
		float h = i * headingIncrement + InitialWheelHeadingDeg;
		WheelHeadings[i] = degreesToRadians(h);
	}

	float wheelSpeeds[NWheels];

	setTouchLEDRGB(pTouch, 255, 0, 0);
	startGyroCalibration(pGyro, 2048);
	while( getGyroCalibrationFlag(pGyro) )
		sleep(50);
	resetGyro(pGyro);
	setTouchLEDRGB(pTouch, 0, 255, 0);

	while(true){
		int driveY = getJoyDriveY();
		int driveX = getJoyDriveX();
		float driveHeading = atan2(driveY, driveX);
		float driveMagnitude = sqrt( driveX*driveX + driveY*driveY ) / ControllerJoyMax;
		float driveRotation = -getJoyDriveR() / ControllerJoyMax;

		int robotHeading = getGyroHeading(pGyro);
		setMotorTarget(mpHeading, robotHeading, 100);
		displayTextLine(1, "%d", robotHeading);

		driveHeading += degreesToRadians(robotHeading);

		for( int i = 0; i < NWheels; ++i ){
			float angleWithTarget = ( driveHeading - WheelHeadings[i] );
			wheelSpeeds[i] = driveMagnitude * cos(angleWithTarget) + driveRotation;
		}

		float maxSpeed = maxOf(wheelSpeeds, NWheels);
		float speedFactor = MotorSpeedMax;
		if( maxSpeed > 1.0 ){
			speedFactor /= maxSpeed;
		}

		for( int i = 0; i < NWheels; ++i ){
			setMotorSpeed( MotorPorts[i], speedFactor * wheelSpeeds[i] );
		}
	}
}
