#pragma config(Motor,  motor3,          mpDriveA,      tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor4,          mpDriveC,      tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor10,         mpDriveB,      tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include <CKGeneralUtilities.h>
#include <CKVexControllers.h>


#define JoyChDriveX		JoyChLX
#define JoyChDriveY		JoyChLY
#define JoyChDriveR		JoyChRX


#define getJoyDriveY()	getJoystickValue(JoyChDriveY)
#define getJoyDriveX()	getJoystickValue(JoyChDriveX)
#define getJoyDriveR()	getJoystickValue(JoyChDriveR)


const float MotorMax = 100.0;
const float ControllerMax = 127.0;

const int NWheels = 3;
const float InitialWheelHeadingDeg = 60;
const int MotorPorts[NWheels] = { mpDriveA, mpDriveB, mpDriveC };


task main() {
	float headingIncrement = 360.0 / NWheels;
	float WheelHeadings[NWheels];
	for( int i = 0; i < NWheels; ++i ){
		float h = i * headingIncrement + InitialWheelHeadingDeg;
		WheelHeadings[i] = degreesToRadians(h);
	}

	float wheelSpeeds[NWheels];


	//drawLine(1, 1, 126, 43); // bounds of drawable area are [0,0] to [127, 44] from lower left.

	while(true){
		int driveY = getJoyDriveY();
		int driveX = getJoyDriveX();
		float driveHeading = atan2(driveY, driveX);
		float driveMagnitude = sqrt( driveX*driveX + driveY*driveY ) / ControllerMax;
		float driveRotation = -getJoyDriveR() / ControllerMax;

		for( int i = 0; i < NWheels; ++i ){
			float angleWithTarget = abs( driveHeading - WheelHeadings[i] );
			wheelSpeeds[i] = driveMagnitude * cos(angleWithTarget) + driveRotation;
		}

		float maxSpeed = maxOf(wheelSpeeds, NWheels);
		float speedFactor = MotorMax;
		if( maxSpeed > 1.0 ){
			speedFactor /= maxSpeed;
		}

		for( int i = 0; i < NWheels; ++i ){
			setMotorSpeed( MotorPorts[i], speedFactor * wheelSpeeds[i] );
		}
	}
}
